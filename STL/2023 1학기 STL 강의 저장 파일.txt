

==================================
소스.cpp, 저장 시간: 2023-03-03 금요일 오후 12:20:43
==================================
//-----------------------------------------------------------------------------
// 2023 1학기 STL 3월 2일 목78                화 910 목78               (1주 1일)
//-----------------------------------------------------------------------------
// vs 환경: release 모드/x64 >> 포인터 크기 8바이트, Project 환경: C++ 언어 latest, SDL-아니오
//-----------------------------------------------------------------------------
// 한학기 강의를 파일에 저장할 수 있는 코딩 >> save 파일
//-----------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <vector>
#include <chrono>

void save(const std::string& fileName);

int main() {
	std::cout << "2023 STL" << '\n'; // \n << endl과 같은 기능.

	save("소스.cpp");
}

void save(const std::string& fileName)
{
	//fileName을 읽기 모드로 열기
	std::ifstream in{ fileName };

	//char c;
	//in >> std::noskipws; //공백, 엔터 스킵하지 마라
	//while (in >> c) {
	//	std::cout << c;
	//}

	//저장 파일을 덧붙여 쓰기 모드로 열기
	std::ofstream out{ "2023 1학기 STL 강의 저장 파일.txt", std::ios::app };

	//저장 시간을 파일에 기록한다.
	auto now = std::chrono::system_clock::now();			//time_point
	auto utc = std::chrono::system_clock::to_time_t(now);	//UTC 시간으로 변환
	auto lt = localtime(&utc);								//로컬 시간으로 변환

	auto old = out.imbue(std::locale("KO_kr"));		//로캘 변환



	//한국 형식으로 날짜 출력
	out << '\n' << '\n';
	out << "==================================" << '\n';
	out << fileName << std::put_time(lt, ", 저장 시간: %x %A %X") << '\n';
	out << "==================================" << '\n';


	std::cout.imbue(old);									//로캘 복구

	//fileName에 있는 모든 내용을 읽어 저장할 파일에 쓰기
	//STL의 자료구조와 알고리즘을 이용하여 저장하기

	std::vector<char> v{ std::istreambuf_iterator<char>{in}, {} };
	//std::vector<char> v{ 파일의 시작, 파일의 끝 };
	std::copy(v.begin(), v.end(), std::ostream_iterator<char>{out});

	//in.close() 쓰지 않아도 됨. 알아서 소멸자를 부르기 때문 >> RTTI. *****파일 스트림 공부 더하기*****
}

==================================
소스.cpp, 저장 시간: 2023-03-07 화요일 오후 5:36:52
==================================
//-----------------------------------------------------------------------------
// 2023 1학기 STL 3월 7일 화910               화 910 목78               (1주 2일)
//-----------------------------------------------------------------------------
// vs 환경: release 모드/x64 >> 포인터 크기 8바이트, Project 환경: C++ 언어 latest, SDL-아니오
//-----------------------------------------------------------------------------
// 한학기 강의를 파일에 저장할 수 있는 코딩 >> save 파일
// save() 함수를 파일로 분리한다.
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"



int main() {
	std::cout << "2023 STL" << '\n'; // \n << endl과 같은 기능.

	using namespace std::string_literals;
	save("소스.cpp"s);
}


==================================
save.h, 저장 시간: 2023-03-07 화요일 오후 5:48:27
==================================
//-------------------------------------------------------------------------
// save.h 한 학기 강의를 저장한다.
// #pragma once >> 두 번 인클루드 하지 말아라.
//-------------------------------------------------------------------------
// #pragma once

#ifndef MY_SAVE_FILE
#define MY_SAVE_FILE

#include <iostream>
#include <fstream>
#include <vector>
#include <chrono>

void save(const std::string& fileName);

#endif 

==================================
save.cpp, 저장 시간: 2023-03-07 화요일 오후 5:48:28
==================================
//-------------------------------------------------------------------------
// save.cpp 한 학기 강의를 저장한다.
//-------------------------------------------------------------------------
#include <string>
#include <fstream>
#include <chrono>
#include "save.h"

void save(const std::string& fileName)
{
	//fileName을 읽기 모드로 열기
	std::ifstream in{ fileName };

	//char c;
	//in >> std::noskipws; //공백, 엔터 스킵하지 마라
	//while (in >> c) {
	//	std::cout << c;
	//}

	//저장 파일을 덧붙여 쓰기 모드로 열기
	std::ofstream out{ "2023 1학기 STL 강의 저장 파일.txt", std::ios::app };

	//저장 시간을 파일에 기록한다.
	auto now = std::chrono::system_clock::now();			//time_point
	//using namespace std::literals::chrono_literals;
	//std::cout << "현재 시간 - " << now + 9h << '\n';

	auto utc = std::chrono::system_clock::to_time_t(now);	//UTC 시간으로 변환
	auto lt = localtime(&utc);								//로컬 시간으로 변환
	auto old = out.imbue(std::locale("KO_kr"));				//로캘 변환



	//한국 형식으로 날짜 출력
	out << '\n' << '\n';
	out << "==================================" << '\n';
	out << fileName << std::put_time(lt, ", 저장 시간: %x %A %X") << '\n';
	out << "==================================" << '\n';


	std::cout.imbue(old);									//로캘 복구

	//fileName에 있는 모든 내용을 읽어 저장할 파일에 쓰기
	//STL의 자료구조와 알고리즘을 이용하여 저장하기

	std::vector<char> v{ std::istreambuf_iterator<char>{in}, {} };
	//std::vector<char> v{ 파일의 시작, 파일의 끝 };
	std::copy(v.begin(), v.end(), std::ostream_iterator<char>{out});

	//in.close() 쓰지 않아도 됨. 알아서 소멸자를 부르기 때문 >> RAII. *****파일 스트림 공부 더하기*****
}

==================================
소스.cpp, 저장 시간: 2023-03-07 화요일 오후 5:48:28
==================================
//-----------------------------------------------------------------------------
// 2023 1학기 STL 3월 2일 목78                화 910 목78               (1주 1일)
//-----------------------------------------------------------------------------
// vs 환경: release 모드/x64 >> 포인터 크기 8바이트, Project 환경: C++ 언어 latest, SDL-아니오
//-----------------------------------------------------------------------------
// 한학기 강의를 파일에 저장할 수 있는 코딩 >> save 파일
// save() 함수를 파일로 분리한다.
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"

int main() {
	save("save.h");
	save("save.cpp");
	save("소스.cpp");
}

==================================
소스.cpp, 저장 시간: 2023-03-07 화요일 오후 6:00:39
==================================
//-----------------------------------------------------------------------------
// 2023 1학기 STL 3월 7일 화910                화 910 목78               (1주 2일)
//-----------------------------------------------------------------------------
// C++ template 복습
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std; //권장하지 않음.

//[문제] 의도대로 실행되도록 코딩하라. main() 안의 내용은 변경 금지

void change(int&, int& );

//-------------
int main() {
//-------------

	int a{ 1 }, b{ 2 };
	change( a, b );
	cout << a << ", " << b << '\n';		//2, 1
	save("소스.cpp");
}

void change(int& a, int& b) {
	int temp{ a };
	a = b;
	b = temp;
}

==================================
소스.cpp, 저장 시간: 2023-03-07 화요일 오후 6:20:07
==================================
//-----------------------------------------------------------------------------
// 2023 1학기 STL 3월 7일 화910                화 910 목78               (1주 2일)
//-----------------------------------------------------------------------------
// C++ template 복습
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std; //권장하지 않음.

//[문제] 의도대로 실행되도록 코딩하라. main() 안의 내용은 변경 금지
class Dog {
public:
	int n;
	Dog(int a) {
		n = a;
	}
};

void change(Dog&, Dog& );
void change(int&, int&);
//-------------
int main() {
//-------------
	{
		Dog a{ 1 }, b{ 2 };
		change( a, b );
		cout << a.n << ", " << b.n << '\n';		//2, 1
	}

	{
		int a{ 1 }, b{ 2 };
		change(a, b);
		cout << a << ", " << b << '\n';		//2, 1
	}
	save("소스.cpp");
}

void change(Dog& a, Dog& b) {
	Dog temp{ a };
	a = b;
	b = temp;
}
void change(int& a, int& b) {
	int temp{ a };
	a = b;
	b = temp;
}

==================================
소스.cpp, 저장 시간: 2023-03-07 화요일 오후 6:27:34
==================================
//-----------------------------------------------------------------------------
// 2023 1학기 STL 3월 7일 화910                화 910 목78               (1주 2일)
//-----------------------------------------------------------------------------
// C++ template 복습
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std; //권장하지 않음.

//[문제] 의도대로 실행되도록 코딩하라. main() 안의 내용은 변경 금지

class Dog {
	int n;
public:
	Dog(int n) : n{ n } {
	}
	//출력 함수 오버로딩 필요!! (***오퍼레이터 오버로딩 다시 공부하기***)
	friend ostream& operator<<(ostream& os, const Dog& Dog) {
		return os << Dog.n;
	}
};

// 함수 오버로딩
void change(Dog&, Dog& );
void change(int&, int&);
 
//-------------
int main() {
//-------------
	{

		Dog a{ 1 }, b{ 2 };
		change( a, b );
		cout << a << ", " << b << '\n';		//2, 1
	}

	{
		int a{ 1 }, b{ 2 };
		change(a, b);
		cout << a << ", " << b << '\n';		//2, 1
	}
	save("소스.cpp");
}

void change(Dog& a, Dog& b) {
	Dog temp{ a };
	a = b;
	b = temp;
}
void change(int& a, int& b) {
	int temp{ a };
	a = b;
	b = temp;
}

==================================
소스.cpp, 저장 시간: 2023-03-07 화요일 오후 6:39:01
==================================
//-----------------------------------------------------------------------------
// 2023 1학기 STL 3월 7일 화910                화 910 목78               (1주 2일)
//-----------------------------------------------------------------------------
// C++ template 복습
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std; //권장하지 않음.

//[문제] 의도대로 실행되도록 코딩하라. main() 안의 내용은 변경 금지
// change 함수를 한 번만 코딩해서 할 수 있나?

class Dog {
	int n;
public:
	Dog(int n) : n{ n } {
	}
	//출력 함수 오버로딩 필요!! (***오퍼레이터 오버로딩 다시 공부하기***)
	friend ostream& operator<<(ostream& os, const Dog& Dog) {
		return os << Dog.n;
	}
};

template <class T>
void change( T&, T&);

// 함수 오버로딩
// void change(Dog&, Dog&);
// void change(Monster&, Monster&);
 
//-------------
int main() {
//-------------
	{

		Dog a{ 1 }, b{ 2 };
		change( a, b );
		cout << a << ", " << b << '\n';		//2, 1
	}

	{
		int a{ 1 }, b{ 2 };
		change(a, b);
		cout << a << ", " << b << '\n';		//2, 1
	}
	save("소스.cpp");
}

template <class T>
void change(T& a, T& b) {
	T temp{ a };							//special 함수 (복사 생성자, 생성자, 소멸자, 이퀄... 그다음이 먼데)
	a = b;									//special 함수 a.operator=(b);와 같은 문장.
	b = temp;
}

==================================
소스.cpp, 저장 시간: 2023-03-07 화요일 오후 6:43:46
==================================
//-----------------------------------------------------------------------------
// 2023 1학기 STL 3월 7일 화910                화 910 목78               (1주 2일)
//-----------------------------------------------------------------------------
// C++ template 복습
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std; //권장하지 않음.

//[문제] 의도대로 실행되도록 코딩하라. main() 안의 내용은 변경 금지
// change 함수를 한 번만 코딩해서 할 수 있나?

class Dog {
	int n;
public:
	Dog(int n) : n{ n } {
	}

	friend ostream& operator<<(ostream& os, const Dog& Dog) {	//출력 함수 오버로딩 필요!! (***오퍼레이터 오버로딩 다시 공부하기***)
		return os << Dog.n;
	}
};

//-------------------------------------------------------------------------------------------
// 함수 오버로딩 >> 자료형의 개수는 무한대임. 따라서 탬플릿으로 하나의 함수만 만들어야 됨.
// void change(Dog&, Dog&);
// void change(Monster&, Monster&);
//-------------------------------------------------------------------------------------------

template <class T>
void change( T&, T&);
 
//-------------
int main() {
//-------------
	{
		Dog a{ 1 }, b{ 2 };
		change( a, b );						// 1. change( Dog, Dog);
											// 2. change( Dog&, Dog&);
											// 3. 템플릿으로 코드 생성.
		cout << a << ", " << b << '\n';		//2, 1
	}

	{
		int a{ 1 }, b{ 2 };
		change(a, b);
		cout << a << ", " << b << '\n';		//2, 1
	}
	save("소스.cpp");
}

template <class T>
void change(T& a, T& b) {
	T temp{ a };							//special 함수 (복사 생성자, 생성자, 소멸자, 이퀄... 그다음이 먼데)
	a = b;									//special 함수 a.operator=(b);와 같은 문장.
	b = temp;
}

==================================
소스.cpp, 저장 시간: 2023-03-07 화요일 오후 7:02:13
==================================
//-----------------------------------------------------------------------------
// 2023 1학기 STL 3월 7일 화910                화 910 목78               (1주 2일)
//-----------------------------------------------------------------------------
// C++ template 복습
//-----------------------------------------------------------------------------
// C++의 패러다임 (C++이 뭔데!)
// 1. procedual PL(C)
// 2. object oriented PL(programming Language) (C++) >> 객체 간의 관계가 중요함. (상속, 친구 등등...) >> OOP
// ** 3. generic PL <OOP와 반대임...?> (C++) 자료형과 무관함!!! >>(템플릿으로 구성된...) 함수(알고리즘), 클래스(자료구조) <<< 독보적임.
// 4. template meta PL >> 프로그램을 생성하는 프로그램. <<< 독보적임. meta는 신급임.
// 5. Functional PL
//-----------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include "save.h"
using namespace std; //권장하지 않음.

//[문제] 의도대로 실행되도록 코딩하라. main() 안의 내용은 변경 금지
// change 함수를 한 번만 코딩해서 할 수 있나?

// 템플릿 함수는 선언과 정의를 따로 하지 않고 한 번에 함. <<선언과 동시에 정의!!>>
// 소스 코드를 컴파일러가 언제나 알 수 있도록 정의를 열어둬야 함. (먼저 정의해야 함.)
// **요약: 템플릿의 선언과 정의는 한 번에! - 템플릿 소스는 컴파일러가 언제나 알고 있어야 하기 때문.
template <class T>
void change(T& a, T& b) {
	T temp{ a };							//special 함수 (복사 생성자, 생성자, 소멸자, 이퀄... 그다음이 먼데)
	a = b;									//special 함수 a.operator=(b);와 같은 문장.
	b = temp;
}

//-------------
int main() {
//-------------

	save("소스.cpp");
}



==================================
소스.cpp, 저장 시간: 2023-03-07 화요일 오후 10:28:22
==================================
//-----------------------------------------------------------------------------
// 2023 1학기 STL 3월 7일 화910                화 910 목78               (1주 2일)
//-----------------------------------------------------------------------------
// C++ template 복습
//-----------------------------------------------------------------------------
// C++의 패러다임 (C++이 뭔데!)
// 1. procedual PL(C)
// 2. object oriented PL(programming Language) (C++) >> 객체 간의 관계가 중요함. (상속, 친구 등등...) >> OOP
// ** 3. generic PL <OOP와 반대임...?> (C++) 자료형과 무관함!!! >>(템플릿으로 구성된...) 함수(알고리즘), 클래스(자료구조) <<< 독보적임.
// 4. template meta PL >> 프로그램을 생성하는 프로그램. <<< 독보적임. meta는 신급임.
// 5. Functional PL
//-----------------------------------------------------------------------------
#include <iostream>
#include <algorithm>
#include "save.h"
using namespace std; //권장하지 않음.

//[문제] 의도대로 실행되도록 코딩하라. main() 안의 내용은 변경 금지
// change 함수를 한 번만 코딩해서 할 수 있나?

// 템플릿 함수는 선언과 정의를 따로 하지 않고 한 번에 함. <<선언과 동시에 정의!!>>
// 소스 코드를 컴파일러가 언제나 알 수 있도록 정의를 열어둬야 함. (먼저 정의해야 함.)
// **요약: 템플릿의 선언과 정의는 한 번에! - 템플릿 소스는 컴파일러가 언제나 알고 있어야 하기 때문.
template <class T>
void change(T& a, T& b) {
	T temp{ a };							//special 함수 (복사 생성자, 생성자, 소멸자, 이퀄... 그다음이 먼데)
	a = b;									//special 함수 a.operator=(b);와 같은 문장.
	b = temp;
}

//-------------
int main() {
	//-------------

	save("소스.cpp");
}

